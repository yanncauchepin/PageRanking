#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#define MAX_STRING 30
#define SIZE_BUFFER 1000000

void lecture_fichier(FILE* fp, char** node, double** matrix, int lines) {
    
    char buffer[SIZE_BUFFER];

    char *token;

    int i = 0;
    int j = 0 ;
    
    fgets(buffer, sizeof(buffer), fp); //1ere ligne, noms des noeuds
    token = strtok(buffer, " \n");
    j=0;
    while (token) {
        node[j] = token;
        ++j;
        token = strtok(NULL, " \n");
    }
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
    
        j = 0;
        token = strtok(buffer, " \n");
        token = strtok(NULL, " \n"); //elimination du premier element qui reprend le tableau node
        while (token) {
            matrix[i][j] = atof(token);
            ++j;
            token = strtok(NULL, " \n");
        }
        ++i;
    }
}

int size_matrix(FILE* fp) {
    int c, lines=-1; //On ne compte pas la ligne contenant les noms des noeuds                 
    while((c = fgetc(fp)) != EOF)
    {
        if(c == '\n')
            lines++;
    }
    rewind(fp);
    
    return lines ;
}

void build_matrix(double** matrix, int lines) {
    for(int j=0;j<lines;j++)
            matrix[j]=(double*)malloc(lines*sizeof(double));
}

void clear_matrix(double** matrix, int lines) {
    matrix = (double **)malloc(lines*sizeof(double*));
    for(int j=0;j<lines;j++)
            free(matrix[j]);
    free(matrix) ;
}

void affichage_matrix (double** matrix) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%2f ", matrix[i][j]);
        }
        putchar('\n');
    }
    putchar('\n'); 
}


void build_node (char** node, int lines) {
    for(int j=0;j<lines;j++)
            node[j]=(char*)malloc(MAX_STRING);
}

void clear_node (char** node, int lines) {
    node = (char **)malloc(lines*sizeof(char*));
    for(int j=0;j<lines;j++)
            free(node[j]);
    free(node);
}

double* prod_scal_vec (double a, double*x, int size_x){
    for(int i=0;i<size_x;i++){
        x[i]=a*x[i];    
    }  
    return (x);
}

double* prod_mat_vec(double** m, double*x,int N){
    double* temp=(double*)malloc(N*sizeof(double));
    for(int j=0;j<N;j++){
        temp[j]=0;
    }
    for(int j=0;j<N;j++){
        temp[0]=temp[0]+m[0][j]*x[j];   
    }
    for(int i=1;i<N;i++){
        for(int j=0;j<N;j++){
            temp[i]=temp[i]+m[i][j]*x[j]; 
        }
    }    
    return(temp);
}


double* normalize_vec(double*x,int N){
    double somme = x[0];
    for(int i=1;i<N;i++){
        somme = somme + x[i];
    }
    for(int i=0;i<N;i++){
        x[i]=x[i]/somme;
    }
    return(x);
}

int main(int argc, char* argv[])
{
    /* Lecture de fichier_________________________________________________________________________________________________*/
    
    if (argc < 2) {
        printf("Usage: %s filename\n", argv[0]); // ?
        exit(EXIT_FAILURE);
    }

    FILE *fp;
    fp = fopen(argv[1],"r");
    if ( fp == NULL ){
        puts ("Cannot open source file");
    }

    int lines = size_matrix(fp) ;
    
    double** matrix = (double **)malloc(lines*sizeof(double*));
    build_matrix(matrix, lines) ;
    
    char** node = (char **)malloc(lines*sizeof(char*)) ;
    build_node(node, lines) ;
    
    lecture_fichier(fp, node, matrix, lines) ; 
    for(int i=0 ; i<40 ; i++) {
        printf("%s\n",node[i]);

    }
    //affichage_matrix(matrix) ;

    
    /*Fin de lecture du fichier_________________________________________________________________________________________________*/
    
    /*Algorithme Pagerank_________________________________________________________________________________________________*/
        
    int nb_iter = 200;
    
    double beta = 0.8;
    double constante = (1.0-beta)/lines; // (1-beta / N)
    
    double* q=(double*)malloc(lines*sizeof(double));

    for (int i=0;i<lines;i++){
        q[i] = 1.0/lines;
    }
    double* q_prec=(double*)malloc(lines*sizeof(double)); //q_precedent donc q(k-1)

    double somme ;
    memmove (q_prec, q, lines*sizeof(double)); // Copie de q dans q_prec (donc q(k-1) = q(k))

    for (int i=0;i<nb_iter;i++){
    	//printf("%2f\n",q[0]);

        //Ajout du premier terme de q
        q = prod_scal_vec(beta,prod_mat_vec(matrix,q_prec, lines), lines) ;
        // Calcul somme q_prec[i]
		//printf("%2f\n",q[0]);

        somme = 0;
        for(int j=0;j<lines;j++){
            somme = somme + q_prec[j];            
        }
        somme = somme*constante;

        //Ajout du second terme de q
        for (int k=0 ; k<lines ; k++) {
            q[k] = q[k] + somme ;
        }
        //printf("%2f\n",q[0]);

        // Normalisation q
        q=normalize_vec(q,lines);
        //printf("%2f\n",q[0]);

        memmove (q_prec, q, lines*sizeof(double)); // Copie de q dans q_prec (donc q(k-1) = q(k))

        printf("%d\n",i);

    }
    
    for(int i=0 ; i<40 ; i++) {
        printf("%2f\n",q[i]);

    }
	
    /*Fin de l'algorithme Pagerank_________________________________________________________________________________________________*/
    
    clear_matrix(matrix, lines) ;
    clear_node(node,lines) ;
    return(0);
}
